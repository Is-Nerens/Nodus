<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>DOM add 1000 divs benchmark</title>
<style>
  body { font-family: system-ui, Arial, sans-serif; padding:16px; }
  .controls { margin-bottom:12px; display:flex; gap:8px; align-items:center; }
  button { padding:8px 12px; cursor:pointer; }
  #results { min-width:300px; }
  #container {
    height: 400px;
    width: 100%;
    border: 1px solid #bbb;
    overflow: auto;
    padding: 8px;
    box-sizing: border-box;
    background: #fafafa;
  }
  .item {
    margin:6px 0;
    padding:12px;            /* inner padding you requested */
    background:#fff;
    border:1px solid #ddd;
    box-shadow: 0 1px 0 rgba(0,0,0,0.03);
  }
  .meta { color:#444; font-size:13px; }
</style>
</head>
<body>
  <div class="controls">
    <button id="btn-frag">Add 1000 divs (fragment)</button>
    <button id="btn-one">Add 1000 divs (one-by-one)</button>
    <button id="btn-clear">Clear</button>
    <div id="results" class="meta">idle</div>
  </div>

  <div id="container" aria-live="polite"></div>

<script>
(function () {
  const N = 1000;
  const container = document.getElementById('container');
  const results = document.getElementById('results');
  const btnFrag = document.getElementById('btn-frag');
  const btnOne = document.getElementById('btn-one');
  const btnClear = document.getElementById('btn-clear');

  function makeItem(i) {
    const d = document.createElement('div');
    d.className = 'item';
    // keep text small to avoid heavy string work dominating results
    d.textContent = 'item #' + i;
    return d;
  }

  // helper to format ms
  function ms(n) { return (Math.round(n * 100) / 100) + ' ms'; }

  // Add using DocumentFragment (minimal layout thrashing)
  btnFrag.addEventListener('click', () => {
    results.textContent = 'running fragment add...';
    const t0 = performance.now();

    // create nodes into fragment
    const tCreateStart = performance.now();
    const frag = document.createDocumentFragment();
    for (let i=0; i<N; i++) {
      frag.appendChild(makeItem(i));
    }
    const tCreateEnd = performance.now();

    // append fragment to container (single DOM insertion)
    const tAppendStart = performance.now();
    container.appendChild(frag);
    const tAppendEnd = performance.now();

    const tTotal = tAppendEnd - t0;
    results.textContent =
      'fragment create: ' + ms(tCreateEnd - tCreateStart) +
      ' | append: ' + ms(tAppendEnd - tAppendStart) +
      ' | total: ' + ms(tTotal);
    console.log({
      mode: 'fragment',
      create: tCreateEnd - tCreateStart,
      append: tAppendEnd - tAppendStart,
      total: tTotal
    });
  });

  // Add one-by-one (each append may trigger layout)
  btnOne.addEventListener('click', () => {
    results.textContent = 'running one-by-one add...';
    const t0 = performance.now();

    const tCreateAppendStart = performance.now();
    for (let i=0; i<N; i++) {
      const node = makeItem(i);
      container.appendChild(node);
    }
    const tCreateAppendEnd = performance.now();

    const tTotal = tCreateAppendEnd - t0;
    results.textContent =
      'one-by-one create+append: ' + ms(tCreateAppendEnd - tCreateAppendStart) +
      ' | total: ' + ms(tTotal);
    console.log({
      mode: 'one-by-one',
      create_append: tCreateAppendEnd - tCreateAppendStart,
      total: tTotal
    });
  });

  btnClear.addEventListener('click', () => {
    container.textContent = '';
    results.textContent = 'cleared';
  });

  // small warmup run to reduce JIT variance (no DOM change)
  (function warmup() {
    for (let i=0;i<100;i++) {
      const x = makeItem(i);
      // no append
      void x.textContent;
    }
  })();

})();
</script>
</body>
</html>
